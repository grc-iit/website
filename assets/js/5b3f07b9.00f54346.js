"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[5377],{3387:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"hpc-tutorials/cpp-introduction/cpp-build-with-cmake","title":"Building C++ with CMake","description":"Now that we have seen how to compile C++ code manually, we will discuss","source":"@site/docs/02-hpc-tutorials/04-cpp-introduction/03-cpp-build-with-cmake.md","sourceDirName":"02-hpc-tutorials/04-cpp-introduction","slug":"/hpc-tutorials/cpp-introduction/cpp-build-with-cmake","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-build-with-cmake","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Building C++ Code Manually","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-build-manually"},"next":{"title":"C++ Basic Syntax","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-basic-syntax"}}');var s=n(4848),l=n(8453);const a={},r="Building C++ with CMake",c={},o=[{value:"Setup",id:"setup",level:2},{value:"Basic C++ Repo Structure",id:"basic-c-repo-structure",level:2},{value:"Building a CMake Project",id:"building-a-cmake-project",level:2},{value:"Top-Level (or Root) CMakeLists.txt",id:"top-level-or-root-cmakeliststxt",level:2},{value:"CMake Preamble",id:"cmake-preamble",level:3},{value:"Global Compiler Flags",id:"global-compiler-flags",level:3},{value:"Build Options",id:"build-options",level:3},{value:"Output Directories",id:"output-directories",level:3},{value:"Locating Dependencies",id:"locating-dependencies",level:3},{value:"Enable Testing",id:"enable-testing",level:3},{value:"Directory Descent",id:"directory-descent",level:3},{value:"src/CMakeLists.txt",id:"srccmakeliststxt",level:2},{value:"Including Header Files",id:"including-header-files",level:3},{value:"Creating a Shared Library",id:"creating-a-shared-library",level:3},{value:"Creating an Executable",id:"creating-an-executable",level:3},{value:"Installing Libraries + Executables",id:"installing-libraries--executables",level:3},{value:"Installing Header Files",id:"installing-header-files",level:3},{value:"test/CMakeLists.txt",id:"testcmakeliststxt",level:2},{value:"Creating a CTest",id:"creating-a-ctest",level:3},{value:"Putting it All Together",id:"putting-it-all-together",level:3},{value:"Generating a Makefile",id:"generating-a-makefile",level:4},{value:"Building with Make",id:"building-with-make",level:4},{value:"Running the Unit Tests",id:"running-the-unit-tests",level:4},{value:"Installing",id:"installing",level:4}];function d(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"building-c-with-cmake",children:"Building C++ with CMake"})}),"\n",(0,s.jsx)(i.p,{children:"Now that we have seen how to compile C++ code manually, we will discuss\nbuild automation using CMake. Generally, compiling manually is bad\nbecause it's difficult for someone to download your repo and just\nbuild it. Building the repo should not be burdensome."}),"\n",(0,s.jsx)(i.p,{children:"The main objectives of this tutorial are as follows:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Describe the structure of a proper C++ repo"}),"\n",(0,s.jsx)(i.li,{children:"Show how to use CMake to compile a C++ repo"}),"\n",(0,s.jsx)(i.li,{children:"Demonstrate how to build a basic CMakeLists.txt"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"We will re-use the example from section 3.2."}),"\n",(0,s.jsx)(i.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"git clone https://github.com/grc-iit/grc-tutorial.git\ncd grc-tutorial\nexport GRC_TUTORIAL=${PWD}\ncd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake\n"})}),"\n",(0,s.jsx)(i.p,{children:"Next perform:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"spack install boost\nspack load boost\n"})}),"\n",(0,s.jsx)(i.h2,{id:"basic-c-repo-structure",children:"Basic C++ Repo Structure"}),"\n",(0,s.jsx)(i.p,{children:"Generally, a C++ repo will contain at least the following directories"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"include: where public header files go"}),"\n",(0,s.jsx)(i.li,{children:"src: where private source and header files go"}),"\n",(0,s.jsx)(i.li,{children:"test: where unit tests go"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Note: A unit test is just a program which validates the correctness\nof some component of your program."}),"\n",(0,s.jsx)(i.p,{children:"In CMake, build configurations are stored in files called CMakeLists.txt.\nIn each directory which has source code or contains a directory which\nhas source code, there should be a file called CMakeLists.txt. The\nCMakeLists.txt is responsible for determining which source codes are\nused for building a library or executable, dependencies, etc."}),"\n",(0,s.jsx)(i.h2,{id:"building-a-cmake-project",children:"Building a CMake Project"}),"\n",(0,s.jsx)(i.p,{children:"To build this project, do the following:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"cd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake\nmkdir build\ncd build\n# CMake will produce a Makefile (in this case)\ncmake ../\n# Use make to build\nmake -j8\n"})}),"\n",(0,s.jsx)(i.p,{children:"CMake is a build system generator, so it doesn't always need to\nbe a makefile which gets produced. It could also be something\nlike ninja. But generally it is make on Linux systems."}),"\n",(0,s.jsx)(i.h2,{id:"top-level-or-root-cmakeliststxt",children:"Top-Level (or Root) CMakeLists.txt"}),"\n",(0,s.jsx)(i.p,{children:"First we will look at the CMakeLists.txt file in the project's root\ndirectory. Generally, the root CMake is responsible for the following:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Finding packages (e.g., shared libraries) which are relevant to the build"}),"\n",(0,s.jsx)(i.li,{children:"Defining user configuration options"}),"\n",(0,s.jsx)(i.li,{children:"Setting variables global to the build"}),"\n",(0,s.jsx)(i.li,{children:"Setting compiler flags (e.g., optimization)"}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["In this section, we will describe our root ",(0,s.jsx)(i.a,{href:"https://github.com/grc-iit/grc-tutorial/blob/main/cpp/03-cpp-build-with-cmake/CMakeLists.txt",children:"CMakeLists.txt"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"cmake-preamble",children:"CMake Preamble"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"cmake_minimum_required (VERSION 3.10)\nproject(MyFirstCMake)\nset(CMAKE_CXX_STANDARD 17)\n"})}),"\n",(0,s.jsx)(i.p,{children:"Here we require a minimum of CMake 3.10. This will cause CMake to fail\nif the installed version is too old."}),"\n",(0,s.jsxs)(i.p,{children:["We also set the name of this project to be MyFirstCMake. The ",(0,s.jsx)(i.em,{children:"project"}),"\nfunction will set the name of this project and store it in the variable\nPROJECT_NAME. Calling from the top-level CMakeLists.txt also stores the project\nname in the variable CMAKE_PROJECT_NAME."]}),"\n",(0,s.jsx)(i.h3,{id:"global-compiler-flags",children:"Global Compiler Flags"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:'#------------------------------------------------------------------------------\n# Compiler optimization\n#------------------------------------------------------------------------------\nadd_compile_options("-fPIC")\nif (CMAKE_BUILD_TYPE STREQUAL "Debug")\n  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O0")\nelseif(CMAKE_BUILD_TYPE STREQUAL "RelWithDebInfo")\n  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O2")\nelseif(CMAKE_BUILD_TYPE STREQUAL "Release")\n  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -03")\nelse()\n  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -03")\nendif()\n'})}),"\n",(0,s.jsx)(i.p,{children:"CMake defines the following variables automatically:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"CMAKE_CXX_STANDARD: The C++ version. For now C++17."}),"\n",(0,s.jsx)(i.li,{children:"CMAKE_BUILD_TYPE: What mode to build your project in. Typically\nthis indicates compiler optimization. Default is usually RelWithDebInfo"}),"\n",(0,s.jsx)(i.li,{children:"CMAKE_CXX_FLAGS: Flags to pass to the compiler. By default, this\nwill be equivalent to the CXX_FLAGS environment variable from the\nshell CMake gets executed in."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"In this example, we define four CMAKE_BUILD_TYPES:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Debug: no compiler optimization"}),"\n",(0,s.jsx)(i.li,{children:"RelWithDebInfo: moderate compiler optimization"}),"\n",(0,s.jsx)(i.li,{children:"Release: heavy compiler optimization"}),"\n",(0,s.jsx)(i.li,{children:"Everything else: same as Release"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"These build types are very common in CMake projects."}),"\n",(0,s.jsx)(i.p,{children:"In section 3.2, we mentioned that the -fPIC flag was required when\nbuilding a shared library. In CMake this flag can be added to all\nlibraries as follows:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:'add_compile_options("-fPIC")\n'})}),"\n",(0,s.jsx)(i.p,{children:"For each CMake build type, we also enable different levels of optimization.\nFor example, with Debug we disabled compiler optimization as follows:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:'set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O0")\n'})}),"\n",(0,s.jsx)(i.p,{children:"Setting CMAKE_CXX_FLAGS and add_compile_options are effectively the same thing.\nIn this case, it would also be equivalent (and actually encouraged) to write:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:'add_compile_options("-O0")\n'})}),"\n",(0,s.jsx)(i.p,{children:"However, in many C++ projects people will set CMAKE_CXX_FLAGS. The main\ndifference between the two approaches is that CMAKE_CXX_FLAGS will apply\nglobally, even if set in a lower-level CMakeLists.txt. This is partially due to\nhistorical reasons."}),"\n",(0,s.jsx)(i.h3,{id:"build-options",children:"Build Options"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:'option(BUILD_TESTING "Build testing kits" OFF)\n'})}),"\n",(0,s.jsx)(i.p,{children:"The option command allows users to configure the build. In this case, we include\na flag which indicates whether or not to build unit tests. In many cases, users\nwon't want to take the time to test code unless there are potential\nportability issues. By default, this value is set to OFF. The alternative is to\nset it to ON."}),"\n",(0,s.jsx)(i.p,{children:"CMake options are passed to CMake using the -D flag. To build this project with testing, do the following:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"cd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake\nmkdir build\ncd build\n# Enable testing\ncmake ../ -DBUILD_TESTING=ON\n# Build\nmake -j8\n"})}),"\n",(0,s.jsx)(i.h3,{id:"output-directories",children:"Output Directories"}),"\n",(0,s.jsx)(i.p,{children:"In this section, we will describe how to define where CMake should output\nexecutables and shared objects."}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:'#------------------------------------------------------------------------------\n# Setup CMake Output Directories\n#------------------------------------------------------------------------------\nset(CMAKE_RUNTIME_OUTPUT_DIRECTORY\n        ${CMAKE_BINARY_DIR}/bin CACHE PATH "Single Directory for all Executables.")\nset(CMAKE_LIBRARY_OUTPUT_DIRECTORY\n        ${CMAKE_BINARY_DIR}/bin CACHE PATH "Single Directory for all Libraries")\nset(CMAKE_ARCHIVE_OUTPUT_DIRECTORY\n        ${CMAKE_BINARY_DIR}/bin CACHE PATH "Single Directory for all static libraries.")\n'})}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"CMAKE_RUNTIME_OUTPUT_DIRECTORY: output for executables"}),"\n",(0,s.jsx)(i.li,{children:"CMAKE_LIBRARY_OUTPUT_DIRECTORY: output for shared libraries"}),"\n",(0,s.jsx)(i.li,{children:"CMAKE_ARCHIVE_OUTPUT_DIRECTORY: output for static libraries (not important for us)"}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["CMAKE_BINARY_DIR is automatically provided by CMake. This is the absolute\npath to the directory which contains the root CMake. In our case, this would\nbe ",(0,s.jsx)(i.code,{children:"cd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"In this example, we output all executables and shared objects to the bin\ndirectory."}),"\n",(0,s.jsx)(i.h3,{id:"locating-dependencies",children:"Locating Dependencies"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#-----------------------------------------------------------------------------\n# Dependencies common to all subdirectories\n#-----------------------------------------------------------------------------\nfind_package(Boost COMPONENTS system filesystem REQUIRED)\n"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"find_package"})," is used to locate packages installed on the system by parsing the\nenvironment variable CMAKE_PREFIX_PATH. CMAKE_PREFIX_PATH must contain the paths\nto .cmake (not .txt) files which actually load the package information. This\nvariable is often set by spack when loading packages."]}),"\n",(0,s.jsx)(i.h3,{id:"enable-testing",children:"Enable Testing"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#-----------------------------------------------------------------------------\n# Enable Testing\n#-----------------------------------------------------------------------------\ninclude(CTest)\nif(CMAKE_PROJECT_NAME STREQUAL MyFirstCMake AND BUILD_TESTING)\n  enable_testing()\nendif()\n"})}),"\n",(0,s.jsx)(i.p,{children:"This code will enable the ability to use a functionality called CTest.\nCTests are used for automating unit tests for C++ projects. In our\ncase, this is only enabled when BUILD_TESTING is ON."}),"\n",(0,s.jsx)(i.h3,{id:"directory-descent",children:"Directory Descent"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#-----------------------------------------------------------------------------\n# Source\n#-----------------------------------------------------------------------------\nadd_subdirectory(src)\n\n#-----------------------------------------------------------------------------\n# Testing Sources\n#-----------------------------------------------------------------------------\nif(CMAKE_PROJECT_NAME STREQUAL MyFirstCMake AND BUILD_TESTING)\n  add_subdirectory(test)\nendif()\n"})}),"\n",(0,s.jsxs)(i.p,{children:["There is no source code in the root directory for this project. In\norder to get to the source code, we must go into the src and test\ndirectories. ",(0,s.jsx)(i.em,{children:"add_subdirectory"})," will tell CMake to go to a specific\ndirectory and execute the CMakeLists.txt in that subdirectory."]}),"\n",(0,s.jsx)(i.h2,{id:"srccmakeliststxt",children:"src/CMakeLists.txt"}),"\n",(0,s.jsxs)(i.p,{children:["In this section, we will discuss ",(0,s.jsx)(i.a,{href:"https://github.com/grc-iit/grc-tutorial/blob/main/cpp/03-cpp-build-with-cmake/src/CMakeLists.txt",children:"src/CMakeLists.txt"}),".\nThis CMake file is responsible for defining how to build + install the\nsource code in this repo."]}),"\n",(0,s.jsx)(i.h3,{id:"including-header-files",children:"Including Header Files"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#------------------------------------------------------------------------------\n# Include Header Directories\n#------------------------------------------------------------------------------\ninclude_directories(${CMAKE_SOURCE_DIR}/include)\n"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"include_directories"})," will ensure that header files can be discovered\nby the C++ compiler. This is analagous to the ",(0,s.jsx)(i.code,{children:"-I"})," flag in the gcc\ncompiler. Here we ensure that the compiler will search the directory\n",(0,s.jsx)(i.code,{children:"${CMAKE_SOURCE_DIR}/include"})," for header files."]}),"\n",(0,s.jsxs)(i.p,{children:["CMAKE_SOURCE_DIR is provided automatically by CMake. It represents\nthe absolute path to the directory containing the root CMakeLists.txt.\nIn our case, this constant would expand to\n",(0,s.jsx)(i.code,{children:"cd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake/"}),"."]}),"\n",(0,s.jsx)(i.h3,{id:"creating-a-shared-library",children:"Creating a Shared Library"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#------------------------------------------------------------------------------\n# Build Database (DB) Library\n#------------------------------------------------------------------------------\nadd_library(database_lib SHARED ${CMAKE_CURRENT_SOURCE_DIR}/database_lib.cc)\ntarget_link_libraries(database_lib\n        ${Boost_FILESYSTEM_LIBRARY}\n        ${Boost_SYSTEM_LIBRARY})\n"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"add_library"}),' will create a shared library, in this case database_lib. This function takes as\ninput the path to all source files related to the build. The SHARED indicates\nthis library is shared (as opposed to static). Here, there is only one source\nfile, datbase_lib.cc. The output of this command will be "libdatabase_lib.so" in\nthe ',(0,s.jsx)(i.code,{children:"build/lib"})," directory."]}),"\n",(0,s.jsxs)(i.p,{children:["CMAKE_CURRENT_SOURCE_DIR is provided automatically by CMake. It represents\nthe absolute path to the directory containing the CMakeLists.txt currently\nbeing processed. In our case, this constant would expand to\n",(0,s.jsx)(i.code,{children:"cd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake/src"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"target_link_libraries"}),' will link all necessary libraries necessary to compile the target database_lib.\nThis is analagous to the "-l" flag in gcc. In our case, we link against the\nBoost System + Filesystem modules. You need to look at specific documentation\nfor each dependency you include in order to include it!']}),"\n",(0,s.jsx)(i.h3,{id:"creating-an-executable",children:"Creating an Executable"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#------------------------------------------------------------------------------\n# Build Grocery DB\n#------------------------------------------------------------------------------\nadd_executable(grocery_db ${CMAKE_CURRENT_SOURCE_DIR}/grocery_db.cc)\nadd_dependencies(grocery_db database_lib)\ntarget_link_libraries(grocery_db database_lib)\n\n#------------------------------------------------------------------------------\n# Build Movies DB\n#------------------------------------------------------------------------------\nadd_executable(movies_db ${CMAKE_CURRENT_SOURCE_DIR}/movies_db.cc)\nadd_dependencies(movies_db database_lib)\ntarget_link_libraries(movies_db database_lib)\n"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"add_executable"})," will create an executable. In our case, the executables\nare movies_db and grocery_db."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"add_dependencies"})," will force certain CMake targets to be built before\nothers. In this case, we need database_lib to be built before movies_db\nand grocery_db."]}),"\n",(0,s.jsxs)(i.p,{children:["In this case, ",(0,s.jsx)(i.em,{children:"target_link_libraries"})," will link database_lib to our executables."]}),"\n",(0,s.jsx)(i.h3,{id:"installing-libraries--executables",children:"Installing Libraries + Executables"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#------------------------------------------------------------------------------\n# Add libraries + executables to CMake install\n#------------------------------------------------------------------------------\ninstall(\n        TARGETS\n        database_lib\n        grocery_db\n        movies_db\n        LIBRARY DESTINATION ${CMAKE_INSTALL_PREFIX}/lib\n        ARCHIVE DESTINATION ${CMAKE_INSTALL_PREFIX}/lib\n        RUNTIME DESTINATION ${CMAKE_INSTALL_PREFIX}/bin)\n"})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"install"}),' defines what happens when a user calls "make install". In this\ncase we specify that our targets database_lib, grocery_db, and movies_db\nshould be installed into one of ',(0,s.jsx)(i.code,{children:"LIBRARY"}),", ",(0,s.jsx)(i.code,{children:"ARCHIVE"}),", or ",(0,s.jsx)(i.code,{children:"RUNTIME"})," depending\non its type. For example, database_lib will be installed to LIBRARY\n(since we used add_library), whereas grocery_db and movies_db will be installed\nto ",(0,s.jsx)(i.code,{children:"RUNTIME"})," (since we used add_executable)."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"CMAKE_INSTALL_PREFIX"})," is a constant provided by CMake which represents\nwhere files should be installed. This can be configured by users by passing\n",(0,s.jsx)(i.code,{children:"-DCMAKE_INSTALL_PREFIX"})," to their CMake build. By default, the value of this\nconstant is /usr."]}),"\n",(0,s.jsx)(i.h3,{id:"installing-header-files",children:"Installing Header Files"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:"#-----------------------------------------------------------------------------\n# Add header file(s) to CMake Install\n#-----------------------------------------------------------------------------\ninstall(\n        FILES\n        ${CMAKE_SOURCE_DIR}/include/database_lib.h\n        DESTINATION\n        ${CMAKE_INSTALL_PREFIX}/include\n        COMPONENT\n        headers)\n"})}),"\n",(0,s.jsxs)(i.p,{children:["In this case, we use ",(0,s.jsx)(i.em,{children:"install"})," to specify\nthat the specific file ",(0,s.jsx)(i.code,{children:"${CMAKE_SOURCE_DIR}/include/database_lib.h"})," should be\ninstalled to ",(0,s.jsx)(i.code,{children:"${CMAKE_INSTALL_PREFIX}/include"}),". Here, we use the keyword\nFILES instead of the keyword TARGET. Targets are defined using a CMake\nfunction such as add_executable or add_library. Files are just the way\nthey are with no modification."]}),"\n",(0,s.jsx)(i.h2,{id:"testcmakeliststxt",children:"test/CMakeLists.txt"}),"\n",(0,s.jsxs)(i.p,{children:["In this section, we will discuss ",(0,s.jsx)(i.a,{href:"https://github.com/grc-iit/grc-tutorial/blob/main/cpp/03-cpp-build-with-cmake/test/CMakeLists.txt",children:"test/CMakeLists.txt"}),". This CMake is responsible for creating unit tests."]}),"\n",(0,s.jsx)(i.h3,{id:"creating-a-ctest",children:"Creating a CTest"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-cmake",children:'add_test(test_grocery_db COMMAND ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/grocery_db)\nset_property(TEST test_grocery_db PROPERTY ENVIRONMENT\n        "LD_LIBRARY_PATH=${CMAKE_LIBRARY_OUTPUT_DIRECTORY}")\n\nadd_test(test_movies_db COMMAND ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/movies_db)\nset_property(TEST test_movies_db PROPERTY ENVIRONMENT\n        "LD_LIBRARY_PATH=${CMAKE_LIBRARY_OUTPUT_DIRECTORY}")\n'})}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"add_test"})," creates a CTest case. Here we create two tests: test_grocery_db\nand test_movies_db. The test will execute the command ",(0,s.jsx)(i.code,{children:"${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/grocery_db"}),"."]}),"\n",(0,s.jsx)(i.p,{children:'CMAKE_RUNTIME_OUTPUT_DIRECTORY is a constant provided by CMake. It\nis the location where an executable is installed after performing the\n"make" command.'}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"set_property"})," sets some sort of property about a target. In this\ncase the target is the test case test_movies_db. We are setting\nan environment variable ",(0,s.jsx)(i.code,{children:"LD_LIBRARY_PATH"}),". From section 3.2, we\nsaw that we needed to be very careful about ensuring the OS\nknows where shared libraries are located. In this case, we\nensure the OS will check the path ",(0,s.jsx)(i.code,{children:"${CMAKE_LIBRARY_OUTPUT_DIRECTORY}"}),"."]}),"\n",(0,s.jsx)(i.p,{children:'CMAKE_LIBRARY_OUTPUT_DIRECTORY is a constant provided by CMake. It\nis the location where a shared library is installed after performing\nthe "make" command.'}),"\n",(0,s.jsx)(i.h3,{id:"putting-it-all-together",children:"Putting it All Together"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"cd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake\nmkdir install\nmkdir build\ncd build\ncmake ../ -DBUILD_TESTING=ON -DCMAKE_INSTALL_PREFIX=../install\nmake -j8\nctest -VV\nmake install\n"})}),"\n",(0,s.jsx)(i.p,{children:"The above code will build, test, and install this example project."}),"\n",(0,s.jsx)(i.h4,{id:"generating-a-makefile",children:"Generating a Makefile"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"cmake ../ -DBUILD_TESTING=ON -DCMAKE_INSTALL_PREFIX=../install\n"})}),"\n",(0,s.jsx)(i.p,{children:"Here we generate a Makefile. The Makefile is used to actually compile\nsource code. Here CMake will create a Makefile which will compile\nunit tests and install data to this tutorial's install directory."}),"\n",(0,s.jsx)(i.h4,{id:"building-with-make",children:"Building with Make"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"make -j8\n"})}),"\n",(0,s.jsx)(i.p,{children:'This command will build with 8 threads (-j indicates parallelism). In our\ncase, it will place all shared libraries and executables underneath the\n"bin" directory.'}),"\n",(0,s.jsx)(i.p,{children:"Just to make sure, list the bin directory:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"ls bin\n"})}),"\n",(0,s.jsx)(i.p,{children:"The output should be as follows:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"grocery_db  libdatabase_lib.so  movies_db\n"})}),"\n",(0,s.jsx)(i.h4,{id:"running-the-unit-tests",children:"Running the Unit Tests"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"ctest -VV\n"})}),"\n",(0,s.jsx)(i.p,{children:"This will run unit tests verbosely, meaning that terminal outputs\nwill not be hidden. -VV indicates making the tests verbose"}),"\n",(0,s.jsx)(i.p,{children:"You should see something like:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"UpdateCTestConfiguration  from :/home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/DartConfiguration.tcl\nParse Config file:/home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/DartConfiguration.tcl\nUpdateCTestConfiguration  from :/home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/DartConfiguration.tcl\nParse Config file:/home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/DartConfiguration.tcl\nTest project /home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build\nConstructing a list of tests\nDone constructing a list of tests\nUpdating test list for fixtures\nAdded 0 tests to meet fixture requirements\nChecking test dependency graph...\nChecking test dependency graph end\ntest 1\n    Start 1: test_grocery_db\n\n1: Test command: /home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/bin/grocery_db\n1: Working Directory: /home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/test\n1: Environment variables: \n1:  LD_LIBRARY_PATH=/home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/bin\n1: Test timeout computed to be: 1500\n1: grocery: in create\n1: grocery: in read\n1: grocery: in update\n1: grocery: in delete\n1/2 Test #1: test_grocery_db ..................   Passed    0.00 sec\ntest 2\n    Start 2: test_movies_db\n\n2: Test command: /home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/bin/movies_db\n2: Working Directory: /home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/test\n2: Environment variables: \n2:  LD_LIBRARY_PATH=/home/luke/Documents/Projects/grc-tutorial/cpp/03-cpp-build-with-cmake/build/bin\n2: Test timeout computed to be: 1500\n2: movies: in create\n2: movies: in read\n2: movies: in update\n2: movies: in delete\n2/2 Test #2: test_movies_db ...................   Passed    0.00 sec\n\n100% tests passed, 0 tests failed out of 2\n\nTotal Test time (real) =   0.01 sec\n"})}),"\n",(0,s.jsx)(i.h4,{id:"installing",children:"Installing"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"make install\n"})}),"\n",(0,s.jsx)(i.p,{children:"This command will create the directories bin, lib, and include in the install\ndirectory we created."}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"bin: all executables"}),"\n",(0,s.jsx)(i.li,{children:"lib: all shared libararies"}),"\n",(0,s.jsx)(i.li,{children:"include: all header files"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Let's list the contents of the install directory and its subdirectories"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"cd ${GRC_TUTORIAL}/cpp/03-cpp-build-with-cmake\nfind install/*\n"})}),"\n",(0,s.jsx)(i.p,{children:"The output should look like:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-bash",children:"install/bin\ninstall/bin/grocery_db\ninstall/bin/movies_db\ninstall/include\ninstall/include/database_lib.h\ninstall/lib\ninstall/lib/libdatabase_lib.so\n"})})]})}function h(e={}){const{wrapper:i}={...(0,l.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>r});var t=n(6540);const s={},l=t.createContext(s);function a(e){const i=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(l.Provider,{value:i},e.children)}}}]);