"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[5203],{4801:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"hpc-tutorials/cpp-introduction/cpp-data-structures","title":"C++ Data Structures","description":"The objective of this section is to provide an overview of the capabilities and","source":"@site/docs/02-hpc-tutorials/04-cpp-introduction/08-cpp-data-structures.md","sourceDirName":"02-hpc-tutorials/04-cpp-introduction","slug":"/hpc-tutorials/cpp-introduction/cpp-data-structures","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-data-structures","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"C++ References and Pointers","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-refs-and-ptrs"},"next":{"title":"Singleton","permalink":"/docs/hpc-tutorials/cpp-introduction/cpp-singleton"}}');var i=n(4848),r=n(8453);const a={},c="C++ Data Structures",l={},d=[{value:"std::vector",id:"stdvector",level:2},{value:"Construct",id:"construct",level:3},{value:"Insert and Modify",id:"insert-and-modify",level:3},{value:"Access",id:"access",level:3},{value:"Erase",id:"erase",level:3},{value:"Capacity &amp; Statistics",id:"capacity--statistics",level:3},{value:"Performance Characteristics",id:"performance-characteristics",level:3},{value:"std::list",id:"stdlist",level:2},{value:"Construct",id:"construct-1",level:3},{value:"Insert + Modify",id:"insert--modify",level:3},{value:"Access",id:"access-1",level:3},{value:"Erase",id:"erase-1",level:3},{value:"Statistics",id:"statistics",level:3},{value:"Performance Characteristics",id:"performance-characteristics-1",level:3},{value:"std::pair",id:"stdpair",level:2},{value:"Construct",id:"construct-2",level:3},{value:"Access + Modify",id:"access--modify",level:3},{value:"std::unordered_map",id:"stdunordered_map",level:2},{value:"Construct",id:"construct-3",level:3},{value:"Insert + Modify",id:"insert--modify-1",level:3},{value:"Access",id:"access-2",level:3},{value:"Statistics",id:"statistics-1",level:3},{value:"Performance Characteristics",id:"performance-characteristics-2",level:3},{value:"std::string",id:"stdstring",level:2},{value:"Construct",id:"construct-4",level:3},{value:"Access",id:"access-3",level:3},{value:"Insert + Modify",id:"insert--modify-2",level:3},{value:"Concatenation",id:"concatenation",level:3},{value:"Conversions",id:"conversions",level:3},{value:"Other Data Structures",id:"other-data-structures",level:2},{value:"A Note on Thread Safety",id:"a-note-on-thread-safety",level:2}];function o(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"c-data-structures",children:"C++ Data Structures"})}),"\n",(0,i.jsx)(t.p,{children:"The objective of this section is to provide an overview of the capabilities and\nperformance characteristics of our favorite data structures. This is not a\ndocumentation page for every single container provided in C++."}),"\n",(0,i.jsx)(t.h2,{id:"stdvector",children:"std::vector"}),"\n",(0,i.jsxs)(t.p,{children:["An ",(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/vector/vector/",children:"std::vector"})," stores objects\nsequentially in memory. They are also known as dynamically-sized arrays. Unlike\ntypical arrays, vectors do not necessarily have a fixed size. We describe the\nbasic usage below. This isn't comprehensive, check the documentation for a full\nlist of features."]}),"\n",(0,i.jsx)(t.h3,{id:"construct",children:"Construct"}),"\n",(0,i.jsx)(t.p,{children:"There are a few ways to create a vector"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorConstruct() {\n  // An empty vector, no space allocated\n  std::vector<int> vec1;\n  // A vector of 100 ints, ints can be any value\n  std::vector<int> vec2(100);\n  // A vector of 100 ints, ints are initialized to 0\n  std::vector<int> vec3(100, 0);\n  // A vector of 5 ints, initialized to 0, 1, 2, 3, 4\n  std::vector<int> vec4{0, 1, 2, 3, 4};\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"insert-and-modify",children:"Insert and Modify"}),"\n",(0,i.jsx)(t.p,{children:"There are a few ways to add and modify elements in a vector"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorModify() {\n  std::vector<int> vec(100);\n  // Add element to the back of a vector\n  // Size of the vector increases by 1 (now 101)\n  vec.emplace_back(2);\n  // Insert element at index 1.\n  // Size of the vector increases by 1 (now 102)\n  vec.emplace(vec.begin() + 1, 1);\n  // Modify first element of vector\n  // Size of the vector does not change (still 102)\n  vec[0] = 1;\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"access",children:"Access"}),"\n",(0,i.jsx)(t.p,{children:"There are various ways to access elements of a vector:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorAccess() {\n  std::vector<int> vec(100);\n  // Get first element (operator)\n  int val1 = vec[0];\n  // Get first element (method)\n  int val2 = vec.front();\n  // Get first element (iterator)\n  std::vector<int>::iterator it3 = vec.begin();\n  int val3 = *it3;\n\n  // Get last element (operator)\n  int val4 = vec[vec.size() - 1];\n  // Get last element (method)\n  int val5 = vec.back();\n  // Get last element (iterator)\n  std::vector<int>::iterator it5 = vec.end() - 1;\n  int val6 = *it5;\n\n  // Get element at index 10 (operator)\n  int val7 = vec[10];\n  // Get element at index 10 (iterator)\n  std::vector<int>::iterator it8 = vec.begin() + 10;\n  int val8 = *it8;\n\n  // Iterate over all elements of the vector\n  for (int &val : vec) {\n      // Do something with val\n  }\n  // Iterate over all elements of the vector\n  for (auto it = vec.begin(); it != vec.end(); ++it) {\n      int &val = *it;\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"erase",children:"Erase"}),"\n",(0,i.jsx)(t.p,{children:"There are a few methods to erase elements from a vector."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\nvoid TestVectorErase() {\n  // Removes the element at index 2 (value 3)\n  std::vector<int> vec1{1, 2, 3, 4, 5};\n  vec1.erase(vec1.begin() + 2);\n  // Removes values 2 through 4\n  // Note, erase does NOT erase the value at vec.begin() + 4\n  std::vector<int> vec2{1, 2, 3, 4, 5};\n  vec2.erase(vec2.begin() + 1, vec2.begin() + 4);\n  // Removes all elements from the vector\n  std::vector<int> vec3{1, 2, 3, 4, 5};\n  vec3.clear();\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"capacity--statistics",children:"Capacity & Statistics"}),"\n",(0,i.jsx)(t.p,{children:"Vectors have two main statistics:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Capacity: the number of elements that can be stored in the vector"}),"\n",(0,i.jsx)(t.li,{children:"Size: the number of elements currently stored in the vector"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Capacity >= Size."}),"\n",(0,i.jsx)(t.p,{children:"To increase capacity without creating new elements, use reserve(). To increase size (i.e., add and construct elements), use resize()."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <vector>\n#include <cassert>  // for assert\nvoid TestVectorSize() {\n  std::vector<int> vec;\n  // Initially empty\n  assert(vec.size() == 0);\n  // Increase to capacity 100\n  vec.reserve(100);\n  assert(vec.size() == 0);\n  assert(vec.capacity() == 100);\n  // Add elements to the vector\n  // emplace_back is fast since there is capacity\n  vec.emplace_back(0);\n  vec.emplace_back(1);\n  assert(vec.size() == 2);\n  // Increase size to 150\n  // Capacity is not necessarily equal to 150\n  vec.resize(150);\n  assert(vec.size() == 150);\n  // Resize can be called with a smaller value\n  vec.resize(50);\n  assert(vec.size() == 50);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Operation"}),(0,i.jsx)(t.th,{children:"Runtime Complexity"}),(0,i.jsx)(t.th,{children:"Memory Complexity"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"emplace_back"}),(0,i.jsx)(t.td,{children:"O(1) amortized. Most of the time, there will be enough capacity in the vector to avoid a reallocation. However, when the capacity is reached, a copy of the vector will be made."}),(0,i.jsx)(t.td,{children:"O(1) or O(N). May end up creating a copy of the vector if capacity is reached."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"emplace"}),(0,i.jsx)(t.td,{children:"O(N) since the vector will have to be shifted. It may also be copied if there's not enough capacity."}),(0,i.jsx)(t.td,{children:"O(1) or O(N). May end up creating a copy of the vector if capacity is reached."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"accessors ([],begin,end,first,last,etc.)"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"reserve"}),(0,i.jsx)(t.td,{children:"O(1) or O(N). O(1) if new size is less than old size. Vectors will not make the data smaller, it will just store the new size. O(N) otherwise."}),(0,i.jsx)(t.td,{children:"O(1) or O(N) for the same reasons."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"resize"}),(0,i.jsx)(t.td,{children:"O(N). Will make a copy of vector if new size is larger than old size. Will erase elements from the vector if new size is smaller than new size."}),(0,i.jsx)(t.td,{children:"O(1) or O(N). O(1) if new size is smaller than old size. O(N) otherwise."})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"erase"}),(0,i.jsx)(t.td,{children:"O(N). Will shift elements after the erased value to the left."}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"size / capacity"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"When to use a vector?"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"If the number of elements is fixed or has a reasonable upper bound"}),"\n",(0,i.jsx)(t.li,{children:"You are performing many get or modify-in-place operations"}),"\n",(0,i.jsx)(t.li,{children:"It makes sense to access an element by an integer index between 0 and\nthe size of the vector"}),"\n",(0,i.jsx)(t.li,{children:"If you do not have to resize the vector often"}),"\n",(0,i.jsx)(t.li,{children:"If random access speeed is important to you"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Considerations of using a vector:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"emplace_back can be slow since it will trigger resizes eventually.\nEven though the amortized cost is O(1), it can be extremely slow\nif inserting many elements."}),"\n",(0,i.jsx)(t.li,{children:"Vectors can have very poor memory utilization if you rely too much\non the dynamic ability. To make them have an O(1) complexity, they multiply\nthe capacity of the vector by a factor. As the size of the vector grows,\nthe space waste can be pretty bad."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"stdlist",children:"std::list"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/list/list/list/",children:"std::list"})," is typically implemented as doubly-linked list. We describe the basic usage below.\nThis isn't comprehensive, check the documentation for a full list\nof features."]}),"\n",(0,i.jsx)(t.h3,{id:"construct-1",children:"Construct"}),"\n",(0,i.jsx)(t.p,{children:"These are the main ways to construct a new std::list."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <list>\nvoid TestListConstruct() {\n  // An empty list\n  std::list<int> list1;\n  // A list of 100 ints, ints can be any value\n  std::list<int> list2(100);\n  // A list of 100 ints, ints are initialized to 0\n  std::list<int> list3(100, 0);\n  // A list of 5 ints, initialized to 0, 1, 2, 3, 4\n  std::list<int> list4{0, 1, 2, 3, 4};\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"insert--modify",children:"Insert + Modify"}),"\n",(0,i.jsx)(t.p,{children:"These are the main ways to insert + modify elements in an std::list."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <list>\n#include <iterator>  // std::next\nvoid TestListModify() {\n  // Add element at front of list\n  // List becomes 0, 1, 2, 3, 4\n  std::list<int> list1{1, 2, 3, 4};\n  list1.emplace_front(0);\n  // Add element at back of list\n  // List becomes 0, 1, 2, 3, 4\n  std::list<int> list2{0, 1, 2, 3};\n  list2.emplace_back(4);\n  // Add element at index 4 in the list\n  // List becomes 0, 1, 2, 3, 4, 5\n  std::list<int> list3{0, 1, 2, 4, 5};\n  list3.emplace(std::next(list3.begin(), 4), 2);\n  // Modify element at index 2 in the list\n  std::list<int> list4{0, 1, 3, 3, 4};\n  std::list<int>::iterator it = std::next(list4.begin(), 2);\n  (*it) = 2;\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"access-1",children:"Access"}),"\n",(0,i.jsx)(t.p,{children:"There are a few ways to access elements in an std::list"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <list>\nvoid TestListAccess() {\n  std::list<int> list{0, 1, 2, 3, 4};\n  // Get first element (method)\n  int val1 = list.front();\n  // Get first element (iterator)\n  std::list<int>::iterator it1 = list.begin();\n  int val2 = *it1;\n  // Get last element (method)\n  int val3 = list.back();\n  // Get last element (iterator)\n  std::list<int>::iterator it2 = list.end();\n  int val4 = *(--it2);\n  // Get element at index 2 (iterator)\n  std::list<int>::iterator it3 = std::next(list.begin(), 2);\n  int val5 = *it3;\n\n  // Iterate over all elements in the list\n  for (int &val : list) {\n      // Do something with val\n  }\n  // Iterate over all elements in the list\n  for (auto &it = list.begin(); it != list.end(); ++it) {\n      int val = *it;\n  }\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"std::next(list.begin(), n) is an O(n) operation. Unlike vectors, lists\nare not stored contiguously in memory so you have to traverse each\nelement of the list."}),"\n",(0,i.jsx)(t.h3,{id:"erase-1",children:"Erase"}),"\n",(0,i.jsx)(t.p,{children:"To erase elements from the list:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"void TestListErase() {\n  // Removes the element at index 2 (value 3)\n  std::list<int> list1{1, 2, 3, 4, 5};\n  list1.erase(std::next(list1.begin(), 2));\n  // Removes values 2 through 4\n  // Note, erase does NOT erase the value at vec.begin() + 4\n  std::list<int> list2{1, 2, 3, 4, 5};\n  list2.erase(std::next(list2.begin(), 1), std::next(list2.begin(), 4));\n  // Removes all elements from the list\n  std::list<int> list3{1, 2, 3, 4, 5};\n  list3.clear();\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"statistics",children:"Statistics"}),"\n",(0,i.jsx)(t.p,{children:"The main statistic that can be queried from a list are its size."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"void TestListStatistic() {\n  std::list<int> list;\n  // Initially empty\n  assert(list.size() == 0);\n  assert(list.empty());\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"performance-characteristics-1",children:"Performance Characteristics"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Operation"}),(0,i.jsx)(t.th,{children:"Runtime Complexity"}),(0,i.jsx)(t.th,{children:"Memory Complexity"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"emplace"}),(0,i.jsx)(t.td,{children:"O(1) when the position being emplaced at is known."}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"std::next"}),(0,i.jsx)(t.td,{children:"O(N)"}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"erase"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"size / capacity"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"When to use a list?"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Frequent insertions and deletions, but few random accesses"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Considerations:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Lists can be inefficient on memory usage. There is a cost to storing\nthe forward and backward pointers -- 16 bytes on 64-bit machine. A list\nof ints, for example, will have to store 20 bytes per entry, whereas a\nvector would be just 4 bytes per entry."}),"\n",(0,i.jsx)(t.li,{children:"List traversals can be inefficient on CPU caches. This is because the prefetcher algorithm has a harder time prediciting what the next memory location is to load into the CPU cache. Make sure the task being performed isn't so performance-critical that this matters."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"stdpair",children:"std::pair"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/utility/pair/",children:"std::pair"}),' is used to represent\ntwo values. They should be used when it is intuitive why one element is first\nand the next element is second. They are often used to represent key-value\npairs, where the key is first and the value is second. Structs are preferred\nover pairs when the elements have more meaningful names than "first" and\n"second".']}),"\n",(0,i.jsx)(t.h3,{id:"construct-2",children:"Construct"}),"\n",(0,i.jsx)(t.p,{children:"A pair can be constructed using the following methods:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <utility>\nvoid TestPairConstruct() {\n  // A pair of ints, initialized to 0, 0\n  std::pair<int, int> pair1;\n  // A pair of ints, initialized to 1, 2\n  std::pair<int, int> pair2(1, 2);\n  // A pair of ints, initialized to 1, 2\n  std::pair<int, int> pair3 = {1, 2};\n  // A pair of ints, initialized to 1, 2\n  std::pair<int, int> pair4 = std::make_pair(1, 2);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"access--modify",children:"Access + Modify"}),"\n",(0,i.jsx)(t.p,{children:'Pairs store data using the "first" and "second" variables.'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <utility>\nvoid TestPairModify() {\n    std::pair<int, int> pair(1, 2);\n    pair.first = 3;\n    pair.second = 4;\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"stdunordered_map",children:"std::unordered_map"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/unordered_map/unordered_map/",children:"std::unordered_map"})," is typically implemented as a chained hashtable. It is\nefficient for lookups and inserts. Entries into the hashtable are unique.\nYou cannot have duplicate entries. Unordered maps can also be referred\nto as key-value stores."]}),"\n",(0,i.jsx)(t.h3,{id:"construct-3",children:"Construct"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <unordered_map>\nvoid TestUnorderedMapConstruct() {\n  // An empty unordered_map\n  std::unordered_map<int, int> map1;\n  // An unordered_map with 100 elements\n  std::unordered_map<int, int> map2(100);\n  // An unordered_map with 5 elements, initialized to 0, 1, 2, 3, 4\n  std::unordered_map<int, int> map3{{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}};\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"insert--modify-1",children:"Insert + Modify"}),"\n",(0,i.jsx)(t.p,{children:"Elements can either be emplaced into the map or overriden using the\nassignment operator. Emplace will fail if the element exists in the\nunordered_map already. Assignment will override the element if it\nexists. It will create a new element if the key doesn't exist in the map."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <unordered_map>\nvoid TestUnorderedMapModify() {\n  // Add a key-value pair to the unordered_map\n  std::unordered_map<int, int> map1;\n  map1.emplace(0, 0);\n  // Modify the value of a key-value pair or create a new one\n  std::unordered_map<int, int> map2{{0, 0}};\n  map2[0] = 1;\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"access-2",children:"Access"}),"\n",(0,i.jsx)(t.p,{children:"There are a few ways to access elements:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <unordered_map>\nvoid TestUnorderedMapAccess() {\n  std::unordered_map<int, int> map{{0, 0}, {1, 1}, {2, 2}};\n  // Get value associated with key 1 (method)\n  int val1 = map.at(1);\n  // Get value associated with key 1 (operator[])\n  int val2 = map[1];\n  // Get value associated with key 1 (iterator)\n  std::unordered_map<int, int>::iterator it = map.find(1);\n  int val3 = it->second;\n\n  // Iterate over the entire unordered map\n  for (const std::pair<int, int> &pair : map) {\n    // Do something with the pair\n  }\n  // Iterate over the entire unordered map\n  // auto &[key, value] is a special syntax for std::pair\n  for (auto &[key, value] : map) {\n    // Do something with the pair\n  }\n  // Iterate over the entire unordered map\n  for (auto it = map.begin(); it != map.end(); ++it) {\n      const std::pair<int, int> &pair = *it;\n  }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"statistics-1",children:"Statistics"}),"\n",(0,i.jsx)(t.p,{children:"The main statistic that can be queried is its size."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <unordered_map>\nvoid TestUnorderedMapStatistics() {\n  std::unordered_map<int, int> map;\n  // Initially empty\n  assert(map.size() == 0);\n  assert(map.empty());\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"performance-characteristics-2",children:"Performance Characteristics"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Operation"}),(0,i.jsx)(t.th,{children:"Runtime Complexity"}),(0,i.jsx)(t.th,{children:"Memory Complexity"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"emplace"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"find"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"erase"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"size / capacity"}),(0,i.jsx)(t.td,{children:"O(1)"}),(0,i.jsx)(t.td,{children:"O(1)"})]})]})]}),"\n",(0,i.jsx)(t.p,{children:"Considerations:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Iterating over an unordered_map can be slow. It has to iterate over\nbuckets and collisions, which has a performance penalty. Iterating over\na list or vector is typically much faster."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"stdstring",children:"std::string"}),"\n",(0,i.jsxs)(t.p,{children:["A string is used to represent an array of characters, typically\nASCII characters. It's similar to an ",(0,i.jsx)(t.code,{children:"std::vector<char>"}),".\nHowever, they have constructors and methods tailored for\nmaking data human-readable, unlike vectors."]}),"\n",(0,i.jsx)(t.p,{children:"We won't document every single thing that can be done with a string\nhere, but they're fairly powerful."}),"\n",(0,i.jsx)(t.h3,{id:"construct-4",children:"Construct"}),"\n",(0,i.jsx)(t.p,{children:"These are the basic ways to construct a string:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <string>\nvoid TestStringConstruct() {\n  // An empty string\n  std::string str1;\n  // A string with 100 'a' characters\n  std::string str2(100, 'a');\n  // A string with 5 elements, initialized to abcde\n  std::string str4 = \"abcde\";\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"Each of these will create a null-terminated string."}),"\n",(0,i.jsx)(t.h3,{id:"access-3",children:"Access"}),"\n",(0,i.jsx)(t.p,{children:"The following demonstrates the primary ways to index a string:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <string>\nvoid TestStringAccess() {\n  std::string str = "abcde";\n  // Get first character (method)\n  char val1 = str.front();\n  // Get first character (operator[])\n  char val2 = str[0];\n  // Get last character (method)\n  char val3 = str.back();\n  // Get last character (operator[])\n  char val4 = str[str.size() - 1];\n  // Get character at index 2 (operator[])\n  char val5 = str[2];\n  // Get a c-style string\n  const char *c_str = str.c_str();\n  const char *c_str2 = str.data();\n  char *data = &str[0];\n  // Iterate over all characters in the string\n  for (char &c : str) {\n      // Do something with c\n  }\n  // Iterate over all characters in the string\n  for (auto it = str.begin(); it != str.end(); ++it) {\n      char &c = *it;\n  }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"insert--modify-2",children:"Insert + Modify"}),"\n",(0,i.jsx)(t.p,{children:"To insert new entries into a string or modify a entries"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <string>\nvoid TestStringModification() {\n  std::string str = "abcde";\n  // Append a character to the end of the string\n  str.push_back(\'f\');\n  // Append a string to the end of the string\n  str.append("ghijk");\n  // Insert a character at index 2\n  str.insert(2, "l");\n  // Insert a string at index 3\n  str.insert(3, "mnopq");\n  // Modify the character at index 2\n  str[2] = \'r\';\n  // Resize a string\n  std::string str2;\n  str2.resize(10);\n  // Reserve space for a string\n  std::string str3;\n  str2.reserve(10);\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"concatenation",children:"Concatenation"}),"\n",(0,i.jsx)(t.p,{children:"Strings can be concatenated using the addition operator."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <string>\nvoid TestStringConcatenation() {\n  std::string str1 = "abc";\n  std::string str2 = "def";\n  // Concatenate two strings\n  std::string str3 = str1 + str2;\n  // Concatenate a string and a character\n  std::string str4 = str1 + \'g\';\n  // Concatenate a string and a C-style string\n  std::string str5 = str1 + "hij";\n  // Concatenate a string and a number\n  std::string str6 = str1 + std::to_string(7);\n  // Concatenate a string and a number\n  std::string str7 = str1 + std::to_string(8.9);\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"conversions",children:"Conversions"}),"\n",(0,i.jsx)(t.p,{children:"A common operation with strings is to convert a number to a string\nand vice-versa."}),"\n",(0,i.jsx)(t.p,{children:"To convert a number to a string:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:"#include <string>\nvoid TestNumberToStringConversion() {\n  int val1 = 123;\n  long val2 = 123;\n  long long val3 = 123;\n  unsigned long val4 = 123;\n  unsigned long long val5 = 123;\n  float val6 = 123.456;\n  double val7 = 123.456;\n  long double val8 = 123.456;\n  // Convert an int to a string\n  std::string str1 = std::to_string(val1);\n  // Convert a long to a string\n  std::string str2 = std::to_string(val2);\n  // Convert a long long to a string\n  std::string str3 = std::to_string(val3);\n  // Convert an unsigned long to a string\n  std::string str4 = std::to_string(val4);\n  // Convert an unsigned long long to a string\n  std::string str5 = std::to_string(val5);\n  // Convert a float to a string\n  std::string str6 = std::to_string(val6);\n  // Convert a double to a string\n  std::string str7 = std::to_string(val7);\n  // Convert a long double to a string\n  std::string str8 = std::to_string(val8);\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"To convert a string to a number:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#include <string>\nvoid TestStringToNumberConversion() {\n  std::string str = "123";\n  // Convert a string to an int\n  int val1 = std::stoi(str);\n  // Convert a string to a long\n  long val2 = std::stol(str);\n  // Convert a string to a long long\n  long long val3 = std::stoll(str);\n  // Convert a string to an unsigned long\n  unsigned long val4 = std::stoul(str);\n  // Convert a string to an unsigned long long\n  unsigned long long val5 = std::stoull(str);\n  // Convert a string to a float\n  float val6 = std::stof(str);\n  // Convert a string to a double\n  double val7 = std::stod(str);\n  // Convert a string to a long double\n  long double val8 = std::stold(str);\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"other-data-structures",children:"Other Data Structures"}),"\n",(0,i.jsx)(t.p,{children:"C++ has various other data structures that may also come up. This list\nis not exhaustive, but these are common ones:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/unordered_set/unordered_set/",children:"std::unordered_set"})," is implemented using a hash table. It's similar to\nan unordered_map."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/queue/queue/",children:"std::queue"})," is a first-in-first-out queue"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/queue/priority_queue/",children:"std::priority_queue"})," is a queue which uses a max heap to implement priorities."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/set/set/",children:"std::set"})," is an ordered set. The order with which elements are inserted are maintained. It's slower than an std::unordered_set in general, so use carefully."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://cplusplus.com/reference/map/map/",children:"std::map"})," is an ordered map. The order with which elements are inserted are maintained. It's slower than an std::unordered_map in general, so use carefully."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"a-note-on-thread-safety",children:"A Note on Thread Safety"}),"\n",(0,i.jsx)(t.p,{children:"STL data structures are not thread-safe. Multiple threads inserting\ninto an unordered_map at the same time, for example, can cause the program\nto be incorrect or segfault. You'll have to use synchronization methods,\nsuch as locks, in order to support concurrent access."})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var s=n(6540);const i={},r=s.createContext(i);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);