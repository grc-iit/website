"use strict";(self.webpackChunkgrc=self.webpackChunkgrc||[]).push([[7319],{5335:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>m,frontMatter:()=>t,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"iowarp/shared-memory/abstractions","title":"Memory Abstractions","description":"The main purpose of hermes-shm is to provide data structures and allocators for managing memory.","source":"@site/docs/07-iowarp/01-shared-memory/02-abstractions.md","sourceDirName":"07-iowarp/01-shared-memory","slug":"/iowarp/shared-memory/abstractions","permalink":"/docs/iowarp/shared-memory/abstractions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Hermes SHM","permalink":"/docs/iowarp/shared-memory/index"},"next":{"title":"Shared Memory Allocators","permalink":"/docs/iowarp/shared-memory/shared-memory"}}');var a=r(4848),s=r(8453);const t={},l="Memory Abstractions",i={},c=[{value:"Memory Backend",id:"memory-backend",level:2},{value:"Allocator",id:"allocator",level:2},{value:"Memory Context",id:"memory-context",level:3},{value:"Memory Manager",id:"memory-manager",level:2},{value:"Thread Model",id:"thread-model",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"memory-abstractions",children:"Memory Abstractions"})}),"\n",(0,a.jsx)(n.p,{children:"The main purpose of hermes-shm is to provide data structures and allocators for managing memory.\nThis can be both private memory and shared memory. This section details the primary\nabstractions used to provide memory management in this library."}),"\n",(0,a.jsx)(n.h2,{id:"memory-backend",children:"Memory Backend"}),"\n",(0,a.jsxs)(n.p,{children:["A memory backend is a region of contiguous memory. Allocators such as ",(0,a.jsx)(n.code,{children:"malloc"})," initially reserve\na large segment of memory to avoid frequent system calls for memory allocation. These memory backends\ncan be for either private or shared memory."]}),"\n",(0,a.jsxs)(n.p,{children:["There are several backends currently supported (",(0,a.jsx)(n.code,{children:"hermes_shm/memory/backend/*"}),"):"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ArrayBackend"}),": takes as input a pointer to memory that was already allocated.\nWorks only for private memory."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"MallocBackend"}),": calls ",(0,a.jsx)(n.code,{children:"malloc"})," to allocate a segment of memory"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"PosixMmapBackend"}),": Uses ",(0,a.jsx)(n.code,{children:"mmap"})," or its equivalent for Windows\nto map a segment of private memory. Similar to ",(0,a.jsx)(n.code,{children:"MallocBackend"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"PosixShmMmap"}),": Uses ",(0,a.jsx)(n.code,{children:"mmap"})," or its equivalent for Windows to\nmap a segment of shared memory."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"CudaShmMmap"}),": Uses ",(0,a.jsx)(n.code,{children:"mmap"})," + cudaHostRegister to allocate memory\nshared across processes and GPU."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"RocmShmMmap"}),": Uses ",(0,a.jsx)(n.code,{children:"mmap"})," + hipHostRegister to allocate memory\nshared across processes and GPU."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"allocator",children:"Allocator"}),"\n",(0,a.jsx)(n.p,{children:"A memory allocator is used to manage a memory backend. Its objective is\nto minimize the number of pages faulted into memory while maintaining\nhigh performance."}),"\n",(0,a.jsxs)(n.p,{children:["Currently, the following are supported (",(0,a.jsx)(n.code,{children:"hermes_shm/memory/allocator/*"}),"):"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"MallocAllocator"}),": Uses malloc internally for allocating. Ignores the\nprovided backend completely."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ScalablePageAllocator"}),": Allocates pages using a single table shared\nacross processes. The table caches different sizes of pages. A lock is\nused to ensure access to the table is synchronized."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ThreadLocalAllocator"}),": Caches different size of pages, but in thread-local\nstorage, removing the lock from ScalablePageAllocator. This is currently\nthe recommended allocator to use for shared memory."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The core API that the allocator supports is shown below:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'template <typename CoreAllocT>\nclass BaseAllocator : public CoreAllocT {\n/**\n   * Create the shared-memory allocator with \\a id unique allocator id over\n   * the particular slot of a memory backend.\n   *\n   * The shm_init function is required, but cannot be marked virtual as\n   * each allocator has its own arguments to this method. Though each\n   * allocator must have "id" as its first argument.\n   * */\n  template <typename... Args>\n  HSHM_CROSS_FUN void shm_init(AllocatorId id, Args... args);\n\n  /**\n   * Deserialize allocator from a buffer.\n   * */\n  HSHM_CROSS_FUN\n  void shm_deserialize(char *buffer, size_t buffer_size);\n\n  /**====================================\n   * Core Allocator API\n   * ===================================*/\n public:\n  /**\n   * Allocate a region of memory of \\a size size\n   * */\n  HSHM_CROSS_FUN\n  OffsetPointer AllocateOffset(const MemContext &ctx, size_t size);\n\n  /**\n   * Allocate a region of memory of \\a size size\n   * and \\a alignment alignment. Assumes that\n   * alignment is not 0.\n   * */\n  HSHM_CROSS_FUN\n  OffsetPointer AlignedAllocateOffset(const MemContext &ctx, size_t size,\n                                      size_t alignment);\n\n  /**\n   * Reallocate \\a pointer to \\a new_size new size.\n   * Assumes that p is not kNulFullPtr.\n   *\n   * @return true if p was modified.\n   * */\n  HSHM_CROSS_FUN\n  OffsetPointer ReallocateOffsetNoNullCheck(const MemContext &ctx,\n                                            OffsetPointer p, size_t new_size);\n\n  /**\n   * Free the memory pointed to by \\a ptr Pointer\n   * */\n  HSHM_CROSS_FUN\n  void FreeOffsetNoNullCheck(const MemContext &ctx, OffsetPointer p);\n\n  /**\n   * Create a thread-local storage segment. This storage\n   * is unique even across processes.\n   * */\n  HSHM_CROSS_FUN\n  void CreateTls(MemContext &ctx) { CoreAllocT::CreateTls(ctx); }\n\n  /**\n   * Free a thread-local storage segment.\n   * */\n  HSHM_CROSS_FUN\n  void FreeTls(const MemContext &ctx) { CoreAllocT::FreeTls(ctx); }\n};\n'})}),"\n",(0,a.jsx)(n.h3,{id:"memory-context",children:"Memory Context"}),"\n",(0,a.jsx)(n.p,{children:"The memory context object is used to store hints on memory allocation.\nThe main hint that this object supports currently is Thread ID."}),"\n",(0,a.jsxs)(n.p,{children:["In most cases, the memory context will be ",(0,a.jsx)(n.code,{children:"HSHM_DEFAULT_MEM_CTX"}),",\nwhich stores a null thread id. This indicates to a memory allocator\nthat it should scan thread-local storage for the current thread id."]}),"\n",(0,a.jsx)(n.h2,{id:"memory-manager",children:"Memory Manager"}),"\n",(0,a.jsxs)(n.p,{children:["The memory manager is where allocators and backends are stored. This\nclass is accessed using a singleton macro ",(0,a.jsx)(n.code,{children:"HSHM_MEMORY_MANAGER"}),".\nUse this class to create allocators and backends."]}),"\n",(0,a.jsx)(n.p,{children:"Below is an example of how one would create a memory allocator for a single process."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:'#include "hermes_shm/hermes_shm.h"\n\nint main() {\n  std::string shm_url = "test_allocators";\n  auto mem_mngr = HSHM_MEMORY_MANAGER;\n  hshm::AllocatorId alloc_id(0, 0);\n  \n  // Create a 1GB backend with id 0\n  mem_mngr->CreateBackend<PosixShmMmap>(\n      hipc::MemoryBackendId::Get(0), hshm::Unit<size_t>::Gigabytes(1), shm_url);\n\n  // Create an allocator over backend 0\n  mem_mngr->CreateAllocator<AllocT>(hipc::MemoryBackendId::Get(0), alloc_id, 0);\n\n  // Unregister allocator\n  mem_mngr->UnregisterAllocator(alloc_id);\n\n  // Destroy backend\n  mem_mngr->DestroyBackend(hipc::MemoryBackendId::Get(0));\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"thread-model",children:"Thread Model"}),"\n",(0,a.jsx)(n.p,{children:"Many memory allocators rely on a specific thread-model to achieve scalability\nusing thread-local storage. Different thread models have different APIs and\nimplementations for this. For that reason, we implement a factory of different\nthread models to handle this circumstance. This is a compile-time factory."}),"\n",(0,a.jsxs)(n.p,{children:["The following thread models are currently supported (",(0,a.jsx)(n.code,{children:"hermes_shm/thread/thread_model/*"}),"):"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Pthreads"}),": Threads for Linux / Mac."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Windows"}),": Threads for Windows."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Argobots"}),": The user-level thread library for Mochi framework."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Cuda"}),": CUDA threads on GPU."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Rocm"}),": ROCm threads on GPU."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The basic API for the thread model is as follows:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"  /** Yield the current thread for a period of time */\n  HSHM_CROSS_FUN\n  void SleepForUs(size_t us);\n\n  /** Yield thread time slice */\n  HSHM_CROSS_FUN\n  void Yield();\n\n  /** Create thread-local storage */\n  template <typename TLS>\n  HSHM_CROSS_FUN bool CreateTls(ThreadLocalKey &key, TLS *data);\n\n  /** Get thread-local storage */\n  template <typename TLS>\n  HSHM_CROSS_FUN TLS *GetTls(const ThreadLocalKey &key);\n\n  /** Create thread-local storage */\n  template <typename TLS>\n  HSHM_CROSS_FUN bool SetTls(ThreadLocalKey &key, TLS *data);\n\n  /** Get the TID of the current thread */\n  HSHM_CROSS_FUN\n  ThreadId GetTid();\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The thread model for the application is stored in a singleton that\ncan be accessed using the macro ",(0,a.jsx)(n.code,{children:"HSHM_THREAD_MODEL"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"Below is an example of accessing the singleton:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cpp",children:"#include <hermes_shm/hermes_shm.h>\n\nint main() {\n  HERMES_THREAD_MODEL->GetTid();\n}\n"})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>t,x:()=>l});var o=r(6540);const a={},s=o.createContext(a);function t(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);